{
    "docs": [
        {
            "location": "/",
            "text": "zend-inputfilter\n\n\n\n\n\n\nThe zend-inputfilter component can be used to filter and validate generic sets\nof input data. For instance, you could use it to filter \n$_GET\n or \n$_POST\n\nvalues, CLI arguments, etc.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-inputfilter/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-inputfilter/",
            "title": "zend-inputfilter"
        },
        {
            "location": "/#zend-inputfilter",
            "text": "The zend-inputfilter component can be used to filter and validate generic sets\nof input data. For instance, you could use it to filter  $_GET  or  $_POST \nvalues, CLI arguments, etc.   File issues at https://github.com/zendframework/zend-inputfilter/issues  Documentation is at https://docs.zendframework.com/zend-inputfilter/",
            "title": "zend-inputfilter"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-inputfilter can be used to filter and validate generic sets of input data.\nFor instance, you could use it to filter \n$_GET\n or \n$_POST\n values, CLI\narguments, etc.\n\n\nTo pass input data to the \nInputFilter\n, use the \nsetData()\n method; the data\nmust be specified using an associative array. Below is an example on how to\nvalidate the data coming from a form using the POST method.\n\n\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\Input;\nuse Zend\\Validator;\n\n$email = new Input('email');\n$email->getValidatorChain()\n      ->attach(new Validator\\EmailAddress());\n\n$password = new Input('password');\n$password->getValidatorChain()\n         ->attach(new Validator\\StringLength(8));\n\n$inputFilter = new InputFilter();\n$inputFilter->add($email);\n$inputFilter->add($password);\n$inputFilter->setData($_POST);\n\nif ($inputFilter->isValid()) {\n    echo \"The form is valid\\n\";\n} else {\n    echo \"The form is not valid\\n\";\n    foreach ($inputFilter->getInvalidInput() as $error) {\n        print_r($error->getMessages());\n    }\n}\n\n\n\nIn this example, we validated the email and password values. The email must be a\nvalid address and the password must be composed of at least 8 characters. If the\ninput data are not valid, we report the list of invalid input using the\n\ngetInvalidInput()\n method.\n\n\nYou can add validators to each input using the \nattach()\n method for each\nvalidator chain. It is also possible to specify a \"validation group\", a subset\nof the data to be validated; this may be done using the \nsetValidationGroup()\n\nmethod. You can specify the list of the input names as an array or as individual\nparameters.\n\n\n// As individual parameters\n$inputFilter->setValidationGroup('email', 'password');\n\n// or as an array of names\n$inputFilter->setValidationGroup(['email', 'password']);\n\n\n\nYou can validate and/or filter the data using the \nInputFilter\n. To filter data,\nuse the \ngetFilterChain()\n method of individual \nInput\n instances, and attach\nfilters to the returned filter chain. Below is an example that uses filtering\nwithout validation.\n\n\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\InputFilter;\n\n$input = new Input('foo');\n$input->getFilterChain()\n      ->attachByName('stringtrim')\n      ->attachByName('alpha');\n\n$inputFilter = new InputFilter();\n$inputFilter->add($input)\n$inputFilter->setData([\n    'foo' => ' Bar3 ',\n]);\n\necho \"Before:\\n\";\necho $inputFilter->getRawValue('foo') . \"\\n\"; // the output is ' Bar3 '\necho \"After:\\n\";\necho $inputFilter->getValue('foo') . \"\\n\";    // the output is 'Bar'\n\n\n\nThe \ngetValue()\n method returns the filtered value of the 'foo' input, while\n\ngetRawValue()\n returns the original value of the input.\n\n\nWe also provide \nZend\\InputFilter\\Factory\n to allow initialization of the\n\nInputFilter\n based on a configuration array or \nTraversable\n object. Below is\nan example where we create a password input value with the same constraints\nproposed before (a string with at least 8 characters):\n\n\nuse Zend\\InputFilter\\Factory;\n\n$factory = new Factory();\n$inputFilter = $factory->createInputFilter([\n    'password' => [\n        'name'       => 'password',\n        'required'   => true,\n        'validators' => [\n            [\n                'name' => 'not_empty',\n            ],\n            [\n                'name' => 'string_length',\n                'options' => [\n                    'min' => 8\n                ],\n            ],\n        ],\n    ],\n]);\n\n$inputFilter->setData($_POST);\necho $inputFilter->isValid() ? 'Valid form' : 'Invalid form';\n\n\n\nThe factory may be used to create not only \nInput\n instances, but also nested\n\nInputFilter\ns, allowing you to create validation and filtering rules for\nhierarchical data sets.\n\n\nFinally, the default \nInputFilter\n implementation is backed by a \nFactory\n. This\nmeans that when calling \nadd()\n, you can provide a specification that the\n\nFactory\n understands, and it will create the appropriate object. You may\ncreate either \nInput\n or \nInputFilter\n objects in this fashion.\n\n\nuse Zend\\InputFilter\\InputFilter;\n\n$filter = new InputFilter();\n\n// Adding a single input\n$filter->add([\n    'name' => 'username',\n    'required' => true,\n    'validators' => [\n        [\n            'name' => 'not_empty',\n        ],\n        [\n            'name' => 'string_length',\n            'options' => [\n                'min' => 5\n            ],\n        ],\n    ],\n]);\n\n// Adding another input filter what also contains a single input. Merging both.\n$filter->add([\n    'type' => 'Zend\\InputFilter\\InputFilter',\n    'password' => [\n        'name' => 'password',\n        'required' => true,\n        'validators' => [\n            [\n                'name' => 'not_empty',\n            ],\n            [\n                'name' => 'string_length',\n                'options' => [\n                    'min' => 8\n                ],\n            ],\n        ],\n    ],\n]);\n\n\n\nThe \nmerge()\n method may be used on an \nInputFilterInterface\n instance in order\nto add two or more filters to each other, effectively allowing you to create\nchains of filters. This is especially useful in object hierarchies that define a\ngeneric set of validation rules on the base object and build on these to create\nmore specific rules.\n\n\nIn the example below, an \nInputFilter\n is built creating name and email\nproperties, allowing them to be re-used elsewhere. When the \nisValid()\n method\nis called on the object, all of the merged filters are run against the calling\nobject in order to validate the internal properties based on our compound set of\nfilters.\n\n\nuse Zend\\InputFilter\\InputFilter;\n\n/**\n * Filter to ensure a name property is set and > 8 characters\n */\nclass NameInputFilter extends InputFilter\n{\n    /** Filter body goes here **/\n}\n\n/**\n * Filter to ensure an email property is set and > 8 characters and is valid\n */\nclass EmailInputFilter extends InputFilter\n{\n    /** Filter body goes here **/\n}\n\nclass SimplePerson\n{\n    /** Member variables omitted for brevity **/\n\n    /** @var InputFilter */\n    protected $inputFilter;\n\n    /**\n     * Retrieve input filter\n     *\n     * @return InputFilter\n     */\n    public function getInputFilter()\n    {\n        if (! $this->inputFilter) {\n            // Create a new input filter\n            $this->inputFilter = new InputFilter();\n\n            // Merge our inputFilter in for the email property\n            $this->inputFilter->merge(new EmailInputFilter());\n\n            // Merge our inputFilter in for the name property\n            $this->inputFilter->merge(new NameInputFilter());\n        }\n\n        return $this->inputFilter;\n    }\n\n    /**\n     * Set input filter\n     *\n     * @param  InputFilterInterface $inputFilter\n     * @return SimplePerson\n     */\n    public function setInputFilter(InputFilterInterface $inputFilter)\n    {\n        $this->inputFilter = $inputFilter;\n\n        return $this;\n    }\n}\n\n\n\nAlso see\n\n\n\n\nzend-filter\n\n\nzend-validator",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-inputfilter can be used to filter and validate generic sets of input data.\nFor instance, you could use it to filter  $_GET  or  $_POST  values, CLI\narguments, etc.  To pass input data to the  InputFilter , use the  setData()  method; the data\nmust be specified using an associative array. Below is an example on how to\nvalidate the data coming from a form using the POST method.  use Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\Input;\nuse Zend\\Validator;\n\n$email = new Input('email');\n$email->getValidatorChain()\n      ->attach(new Validator\\EmailAddress());\n\n$password = new Input('password');\n$password->getValidatorChain()\n         ->attach(new Validator\\StringLength(8));\n\n$inputFilter = new InputFilter();\n$inputFilter->add($email);\n$inputFilter->add($password);\n$inputFilter->setData($_POST);\n\nif ($inputFilter->isValid()) {\n    echo \"The form is valid\\n\";\n} else {\n    echo \"The form is not valid\\n\";\n    foreach ($inputFilter->getInvalidInput() as $error) {\n        print_r($error->getMessages());\n    }\n}  In this example, we validated the email and password values. The email must be a\nvalid address and the password must be composed of at least 8 characters. If the\ninput data are not valid, we report the list of invalid input using the getInvalidInput()  method.  You can add validators to each input using the  attach()  method for each\nvalidator chain. It is also possible to specify a \"validation group\", a subset\nof the data to be validated; this may be done using the  setValidationGroup() \nmethod. You can specify the list of the input names as an array or as individual\nparameters.  // As individual parameters\n$inputFilter->setValidationGroup('email', 'password');\n\n// or as an array of names\n$inputFilter->setValidationGroup(['email', 'password']);  You can validate and/or filter the data using the  InputFilter . To filter data,\nuse the  getFilterChain()  method of individual  Input  instances, and attach\nfilters to the returned filter chain. Below is an example that uses filtering\nwithout validation.  use Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\InputFilter;\n\n$input = new Input('foo');\n$input->getFilterChain()\n      ->attachByName('stringtrim')\n      ->attachByName('alpha');\n\n$inputFilter = new InputFilter();\n$inputFilter->add($input)\n$inputFilter->setData([\n    'foo' => ' Bar3 ',\n]);\n\necho \"Before:\\n\";\necho $inputFilter->getRawValue('foo') . \"\\n\"; // the output is ' Bar3 '\necho \"After:\\n\";\necho $inputFilter->getValue('foo') . \"\\n\";    // the output is 'Bar'  The  getValue()  method returns the filtered value of the 'foo' input, while getRawValue()  returns the original value of the input.  We also provide  Zend\\InputFilter\\Factory  to allow initialization of the InputFilter  based on a configuration array or  Traversable  object. Below is\nan example where we create a password input value with the same constraints\nproposed before (a string with at least 8 characters):  use Zend\\InputFilter\\Factory;\n\n$factory = new Factory();\n$inputFilter = $factory->createInputFilter([\n    'password' => [\n        'name'       => 'password',\n        'required'   => true,\n        'validators' => [\n            [\n                'name' => 'not_empty',\n            ],\n            [\n                'name' => 'string_length',\n                'options' => [\n                    'min' => 8\n                ],\n            ],\n        ],\n    ],\n]);\n\n$inputFilter->setData($_POST);\necho $inputFilter->isValid() ? 'Valid form' : 'Invalid form';  The factory may be used to create not only  Input  instances, but also nested InputFilter s, allowing you to create validation and filtering rules for\nhierarchical data sets.  Finally, the default  InputFilter  implementation is backed by a  Factory . This\nmeans that when calling  add() , you can provide a specification that the Factory  understands, and it will create the appropriate object. You may\ncreate either  Input  or  InputFilter  objects in this fashion.  use Zend\\InputFilter\\InputFilter;\n\n$filter = new InputFilter();\n\n// Adding a single input\n$filter->add([\n    'name' => 'username',\n    'required' => true,\n    'validators' => [\n        [\n            'name' => 'not_empty',\n        ],\n        [\n            'name' => 'string_length',\n            'options' => [\n                'min' => 5\n            ],\n        ],\n    ],\n]);\n\n// Adding another input filter what also contains a single input. Merging both.\n$filter->add([\n    'type' => 'Zend\\InputFilter\\InputFilter',\n    'password' => [\n        'name' => 'password',\n        'required' => true,\n        'validators' => [\n            [\n                'name' => 'not_empty',\n            ],\n            [\n                'name' => 'string_length',\n                'options' => [\n                    'min' => 8\n                ],\n            ],\n        ],\n    ],\n]);  The  merge()  method may be used on an  InputFilterInterface  instance in order\nto add two or more filters to each other, effectively allowing you to create\nchains of filters. This is especially useful in object hierarchies that define a\ngeneric set of validation rules on the base object and build on these to create\nmore specific rules.  In the example below, an  InputFilter  is built creating name and email\nproperties, allowing them to be re-used elsewhere. When the  isValid()  method\nis called on the object, all of the merged filters are run against the calling\nobject in order to validate the internal properties based on our compound set of\nfilters.  use Zend\\InputFilter\\InputFilter;\n\n/**\n * Filter to ensure a name property is set and > 8 characters\n */\nclass NameInputFilter extends InputFilter\n{\n    /** Filter body goes here **/\n}\n\n/**\n * Filter to ensure an email property is set and > 8 characters and is valid\n */\nclass EmailInputFilter extends InputFilter\n{\n    /** Filter body goes here **/\n}\n\nclass SimplePerson\n{\n    /** Member variables omitted for brevity **/\n\n    /** @var InputFilter */\n    protected $inputFilter;\n\n    /**\n     * Retrieve input filter\n     *\n     * @return InputFilter\n     */\n    public function getInputFilter()\n    {\n        if (! $this->inputFilter) {\n            // Create a new input filter\n            $this->inputFilter = new InputFilter();\n\n            // Merge our inputFilter in for the email property\n            $this->inputFilter->merge(new EmailInputFilter());\n\n            // Merge our inputFilter in for the name property\n            $this->inputFilter->merge(new NameInputFilter());\n        }\n\n        return $this->inputFilter;\n    }\n\n    /**\n     * Set input filter\n     *\n     * @param  InputFilterInterface $inputFilter\n     * @return SimplePerson\n     */\n    public function setInputFilter(InputFilterInterface $inputFilter)\n    {\n        $this->inputFilter = $inputFilter;\n\n        return $this;\n    }\n}  Also see   zend-filter  zend-validator",
            "title": "Introduction"
        },
        {
            "location": "/specs/",
            "text": "Input filter specifications\n\n\nZend\\InputFilter\n allows configuration-driven creation of input filters via\n\nZend\\InputFilter\\InputFilterAbstractServiceFactory\n. This abstract factory is\nresponsible for creating and returning an appropriate input filter given named\nconfiguration under the top-level configuration key \ninput_filter_specs\n.\n\n\nIt is registered with \nZend\\InputFilter\\InputFilterPluginManager\n, allowing you\nto pull the input filter via that plugin manager. A side effect is that forms\npulled from \nZend\\Form\\FormElementManager\n can use these named input filters.\n\n\nSetup\n\n\nWhen using zend-mvc version 2 releases, this functionality is disabled by\ndefault.  To enable it, you must add the\n\nZend\\InputFilter\\InputFilterAbstractServiceFactory\n abstract factory to the\n\nZend\\InputFilter\\InputFilterPluginManager\n configuration, which is under the\n\ninput_filters\n configuration key.\n\n\nreturn array(\n    'input_filters' => array(\n        'abstract_factories' => array(\n            'Zend\\InputFilter\\InputFilterAbstractServiceFactory'\n        ),\n    ),\n);\n\n\n\nFor \nExpressive\n when using\nthe configuration manager, and for zend-mvc v3 releases, the functionality is\nenabled by default, assuming you are using the\n\ncomponent installer\n.\n\n\nExample\n\n\nIn the following code, we define configuration for an input filter named \nfoobar\n:\n\n\nreturn [\n    'input_filter_specs' => [\n        'foobar' => [\n            [\n                'name' => 'name',\n                'required' => true,\n                'filters' => [\n                    [\n                        'name' => 'Zend\\Filter\\StringTrim',\n                        'options' => [],\n                    ],\n                ],\n                'validators' => [],\n                'description' => 'Hello to name',\n                'allow_empty' => false,\n                'continue_if_empty' => false,\n            ],\n        ],\n    ],\n];\n\n\n\nWhen creating a controller, we might then pull the \nInputFilterManager\n, and\nretrieve the \nfoobar\n input filter we've defined in order to inject it:\n\n\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass MyValidatingControllerFactory implements FactoryInterface\n{\n    public function createService(ServiceLocatorInterface $controllers)\n    {\n        // Retrieve the application service manager\n        $services = $controllers->getServiceLocator();\n\n        // Retrieve the InputFilterManager\n        $filters = $services->get('InputFilterManager');\n\n        // Instantiate the controller and pass it the foobar input filter\n        return new MyValidatingController($filters->get('foobar'));\n    }\n}\n\n\n\nAnd you can use it as you already did with other input filters:\n\n\n$inputFilter->setData([\n    'name' => 'test',\n]);\n\nif (! $inputFilter->isValid()) {\n    echo 'Data invalid';\n}",
            "title": "Specifications"
        },
        {
            "location": "/specs/#input-filter-specifications",
            "text": "Zend\\InputFilter  allows configuration-driven creation of input filters via Zend\\InputFilter\\InputFilterAbstractServiceFactory . This abstract factory is\nresponsible for creating and returning an appropriate input filter given named\nconfiguration under the top-level configuration key  input_filter_specs .  It is registered with  Zend\\InputFilter\\InputFilterPluginManager , allowing you\nto pull the input filter via that plugin manager. A side effect is that forms\npulled from  Zend\\Form\\FormElementManager  can use these named input filters.",
            "title": "Input filter specifications"
        },
        {
            "location": "/specs/#setup",
            "text": "When using zend-mvc version 2 releases, this functionality is disabled by\ndefault.  To enable it, you must add the Zend\\InputFilter\\InputFilterAbstractServiceFactory  abstract factory to the Zend\\InputFilter\\InputFilterPluginManager  configuration, which is under the input_filters  configuration key.  return array(\n    'input_filters' => array(\n        'abstract_factories' => array(\n            'Zend\\InputFilter\\InputFilterAbstractServiceFactory'\n        ),\n    ),\n);  For  Expressive  when using\nthe configuration manager, and for zend-mvc v3 releases, the functionality is\nenabled by default, assuming you are using the component installer .",
            "title": "Setup"
        },
        {
            "location": "/specs/#example",
            "text": "In the following code, we define configuration for an input filter named  foobar :  return [\n    'input_filter_specs' => [\n        'foobar' => [\n            [\n                'name' => 'name',\n                'required' => true,\n                'filters' => [\n                    [\n                        'name' => 'Zend\\Filter\\StringTrim',\n                        'options' => [],\n                    ],\n                ],\n                'validators' => [],\n                'description' => 'Hello to name',\n                'allow_empty' => false,\n                'continue_if_empty' => false,\n            ],\n        ],\n    ],\n];  When creating a controller, we might then pull the  InputFilterManager , and\nretrieve the  foobar  input filter we've defined in order to inject it:  use Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass MyValidatingControllerFactory implements FactoryInterface\n{\n    public function createService(ServiceLocatorInterface $controllers)\n    {\n        // Retrieve the application service manager\n        $services = $controllers->getServiceLocator();\n\n        // Retrieve the InputFilterManager\n        $filters = $services->get('InputFilterManager');\n\n        // Instantiate the controller and pass it the foobar input filter\n        return new MyValidatingController($filters->get('foobar'));\n    }\n}  And you can use it as you already did with other input filters:  $inputFilter->setData([\n    'name' => 'test',\n]);\n\nif (! $inputFilter->isValid()) {\n    echo 'Data invalid';\n}",
            "title": "Example"
        },
        {
            "location": "/file-input/",
            "text": "File Upload Input\n\n\nThe \nZend\\InputFilter\\FileInput\n class is a special \nInput\n type for uploaded\nfiles found in the \n$_FILES\n array.\n\n\nWhile \nFileInput\n uses the same interface as \nInput\n, it differs in a few ways:\n\n\n\n\nIt expects the raw value to be in a normalized \n$_FILES\n array format. See\n   the \nPSR-7 Uploaded files\n\n   chapter for details on how to accomplish this.\n   \nDiactoros\n and\n   \nzend-http\n can do this for you.\n\n\nThe validators are run \nbefore\n the filters (which is the opposite behavior\n   of \nInput\n). This is so that any \nis_uploaded_file()\n validation can be run\n   prior to any filters that may rename/move/modify the file.\n\n\nInstead of adding a \nNotEmpty\n validator, it will (by default) automatically\n   add a \nZend\\Validator\\File\\UploadFile\n validator.\n\n\n\n\nThe biggest thing to be concerned about is that if you are using a \n<input\ntype=\"file\">\n element in your form, you will need to use the \nFileInput\n\n\ninstead of\n \nInput\n or else you will encounter issues.\n\n\nBasic Usage\n\n\nUsage of \nFileInput\n is essentially the same as \nInput\n:\n\n\nuse Zend\\Http\\PhpEnvironment\\Request;\nuse Zend\\Filter;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\FileInput;\nuse Zend\\Validator;\n\n// Description text input\n$description = new Input('description'); // Standard Input type\n$description->getFilterChain()           // Filters are run first w/ Input\n            ->attach(new Filter\\StringTrim());\n$description->getValidatorChain()        // Validators are run second w/ Input\n            ->attach(new Validator\\StringLength(['max' => 140]));\n\n// File upload input\n$file = new FileInput('file');           // Special File Input type\n$file->getValidatorChain()               // Validators are run first w/ FileInput\n     ->attach(new Validator\\File\\UploadFile());\n$file->getFilterChain()                  // Filters are run second w/ FileInput\n     ->attach(new Filter\\File\\RenameUpload([\n         'target'    => './data/tmpuploads/file',\n         'randomize' => true,\n     ]));\n\n// Merge $_POST and $_FILES data together\n$request  = new Request();\n$postData = array_merge_recursive($request->getPost()->toArray(), $request->getFiles()->toArray());\n\n$inputFilter = new InputFilter();\n$inputFilter->add($description)\n            ->add($file)\n            ->setData($postData);\n\nif ($inputFilter->isValid()) {           // FileInput validators are run, but not the filters...\n    echo \"The form is valid\\n\";\n    $data = $inputFilter->getValues();   // This is when the FileInput filters are run.\n} else {\n    echo \"The form is not valid\\n\";\n    foreach ($inputFilter->getInvalidInput() as $error) {\n        print_r ($error->getMessages());\n    }\n}",
            "title": "Files"
        },
        {
            "location": "/file-input/#file-upload-input",
            "text": "The  Zend\\InputFilter\\FileInput  class is a special  Input  type for uploaded\nfiles found in the  $_FILES  array.  While  FileInput  uses the same interface as  Input , it differs in a few ways:   It expects the raw value to be in a normalized  $_FILES  array format. See\n   the  PSR-7 Uploaded files \n   chapter for details on how to accomplish this.\n    Diactoros  and\n    zend-http  can do this for you.  The validators are run  before  the filters (which is the opposite behavior\n   of  Input ). This is so that any  is_uploaded_file()  validation can be run\n   prior to any filters that may rename/move/modify the file.  Instead of adding a  NotEmpty  validator, it will (by default) automatically\n   add a  Zend\\Validator\\File\\UploadFile  validator.   The biggest thing to be concerned about is that if you are using a  <input\ntype=\"file\">  element in your form, you will need to use the  FileInput  instead of   Input  or else you will encounter issues.",
            "title": "File Upload Input"
        },
        {
            "location": "/file-input/#basic-usage",
            "text": "Usage of  FileInput  is essentially the same as  Input :  use Zend\\Http\\PhpEnvironment\\Request;\nuse Zend\\Filter;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\FileInput;\nuse Zend\\Validator;\n\n// Description text input\n$description = new Input('description'); // Standard Input type\n$description->getFilterChain()           // Filters are run first w/ Input\n            ->attach(new Filter\\StringTrim());\n$description->getValidatorChain()        // Validators are run second w/ Input\n            ->attach(new Validator\\StringLength(['max' => 140]));\n\n// File upload input\n$file = new FileInput('file');           // Special File Input type\n$file->getValidatorChain()               // Validators are run first w/ FileInput\n     ->attach(new Validator\\File\\UploadFile());\n$file->getFilterChain()                  // Filters are run second w/ FileInput\n     ->attach(new Filter\\File\\RenameUpload([\n         'target'    => './data/tmpuploads/file',\n         'randomize' => true,\n     ]));\n\n// Merge $_POST and $_FILES data together\n$request  = new Request();\n$postData = array_merge_recursive($request->getPost()->toArray(), $request->getFiles()->toArray());\n\n$inputFilter = new InputFilter();\n$inputFilter->add($description)\n            ->add($file)\n            ->setData($postData);\n\nif ($inputFilter->isValid()) {           // FileInput validators are run, but not the filters...\n    echo \"The form is valid\\n\";\n    $data = $inputFilter->getValues();   // This is when the FileInput filters are run.\n} else {\n    echo \"The form is not valid\\n\";\n    foreach ($inputFilter->getInvalidInput() as $error) {\n        print_r ($error->getMessages());\n    }\n}",
            "title": "Basic Usage"
        },
        {
            "location": "/optional-input-filters/",
            "text": "Optional Input Filters\n\n\n\n\nSince 2.8.0\n\n\n\n\nNormally, input filters are \nrequired\n, which means that if you compose them as\na subset of another input filter (e.g., to validate a subset of a larger set of\ndata), and no data is provided for that item, or an empty set of data is\nprovided, then the input filter will consider the data invalid.\n\n\nIf you want to allow a set of data to be empty, you can use \n\nZend\\InputFilter\\OptionalInputFilter\n.\n\n\nTo illustrate this, let's consider a form where a user provides profile\ninformation. The user can provide an optional \"title\" and a required \"email\",\nand \noptionally\n details about a project they lead, which will include the\nproject title and a URL, both of which are required if present.\n\n\nFirst, let's create an \nOptionalInputFilter\n instance for the project data:\n\n\n$projectFilter = new OptionalInputFilter();\n$projectFilter->add([\n    'name' => 'project_name',\n    'required' => true,\n]);\n$projectFilter->add([\n    'name' => 'url',\n    'required' => true,\n    'validators' => [\n        ['type' => 'uri'],\n    ],\n]);\n\n\n\nNow, we'll create our primary input filter:\n\n\n$profileFilter = new InputFilter();\n$profileFilter->add([\n    'name' => 'title',\n    'required' => false,\n]);\n$profileFilter->add([\n    'name' => 'email',\n    'required' => true,\n    'validators' => [\n        ['type' => 'EmailAddress'],\n    ],\n]);\n\n// And, finally, compose our project sub-filter:\n$profileFilter->add($projectFilter, 'project');\n\n\n\nWith this defined, we can now validate the following sets of data, presented in\nJSON for readability:\n\n\n\n\nJust profile information:\n\n\n\n\n{\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\"\n}\n\n\n\n\n\nnull\n project provided:\n\n\n\n\n{\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\",\n  \"project\": null\n}\n\n\n\n\n\nEmpty project provided:\n\n\n\n\n{\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\",\n  \"project\": {}\n}\n\n\n\n\n\nValid project provided:\n\n\n\n\n{\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\",\n  \"project\": {\n    \"project_name\": \"zend-inputfilter\",\n    \"url\": \"https://github.com/zend-inputfilter\",\n  }\n}",
            "title": "Optional Input Filters"
        },
        {
            "location": "/optional-input-filters/#optional-input-filters",
            "text": "Since 2.8.0   Normally, input filters are  required , which means that if you compose them as\na subset of another input filter (e.g., to validate a subset of a larger set of\ndata), and no data is provided for that item, or an empty set of data is\nprovided, then the input filter will consider the data invalid.  If you want to allow a set of data to be empty, you can use  Zend\\InputFilter\\OptionalInputFilter .  To illustrate this, let's consider a form where a user provides profile\ninformation. The user can provide an optional \"title\" and a required \"email\",\nand  optionally  details about a project they lead, which will include the\nproject title and a URL, both of which are required if present.  First, let's create an  OptionalInputFilter  instance for the project data:  $projectFilter = new OptionalInputFilter();\n$projectFilter->add([\n    'name' => 'project_name',\n    'required' => true,\n]);\n$projectFilter->add([\n    'name' => 'url',\n    'required' => true,\n    'validators' => [\n        ['type' => 'uri'],\n    ],\n]);  Now, we'll create our primary input filter:  $profileFilter = new InputFilter();\n$profileFilter->add([\n    'name' => 'title',\n    'required' => false,\n]);\n$profileFilter->add([\n    'name' => 'email',\n    'required' => true,\n    'validators' => [\n        ['type' => 'EmailAddress'],\n    ],\n]);\n\n// And, finally, compose our project sub-filter:\n$profileFilter->add($projectFilter, 'project');  With this defined, we can now validate the following sets of data, presented in\nJSON for readability:   Just profile information:   {\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\"\n}   null  project provided:   {\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\",\n  \"project\": null\n}   Empty project provided:   {\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\",\n  \"project\": {}\n}   Valid project provided:   {\n  \"email\": \"user@example.com\",\n  \"title\": \"Software Developer\",\n  \"project\": {\n    \"project_name\": \"zend-inputfilter\",\n    \"url\": \"https://github.com/zend-inputfilter\",\n  }\n}",
            "title": "Optional Input Filters"
        }
    ]
}